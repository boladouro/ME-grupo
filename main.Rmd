---
title: "R Notebook"
output: html_notebook
---

```{r}
if (FALSE) {
  installPackagesNeeded()
}
```

## Processo

Um paciente que está em lista de espera para ser operado:

1. Entra em contacto com o serviço de cirurgia, vários dias antes da sua operação, 
  * Através de uma chamada telefónica ou 
  * Através do envio de uma mensagem escrita numa app.

2. Os serviços administrativos atendem as chamadas ou lêem a mensagem via app e, mediante
  * a informação presente no sistema dada pelo médico assistente e 
  * a informação fornecida pelo paciente, 
o administrativo decide se agenda
  * uma consulta presencial antes da cirurgia, ou
  * uma consulta telefónica, ou
  * não há necessidade de qualquer consulta. 

Contudo, este procedimento necessita de melhorias. 
O objectivo deste estudo é optimizar a gestão dos contactos (tempo total do processo e total de chamadas perdidas)

## Situação atual

1. Apenas 2 administrativos no serviço, ambos começam às 8h e acabam às 18h (10h de trabalho) de cada dia útil.

2. O tempo entre chegadas tem exp(1/40) (pq media de 40/h)

3. Tipo de contacto:
* prob de telefone = 0.85
* prob de app = 0.15

4. Tipo de consulta: 
* 0.3 não é agendado consulta, 
* 0.6 consula por telefone, 
* 0.1 presencial

5. Tempo de 
* Conversa antes da decisao é norm(4,1^2)
* Tomada de decisao do adminstrativo é norm(1,0.25^2)
* Tempo de agendamento SE NECESSÁRIO é norm(1,0.25^2)

6. 5o telefone desliga apos 5 minutos de espera (e fica chamada perdida) 


```{r}
library(simmer)
library(simmer.bricks)
library(simmer.plot)
conflicts_prefer(simmer::rollback)
conflicts_prefer(simmer::now)
conflicts_prefer(dplyr::select)
# this will be substituted below and literally just is here because simmer doesn't know how to implement pipes and I hate it here
env <- simmer("hospital") 
```
Resources:
  Server: O hospital com 2 administradores
  Queue: Fila de espera com prioridade de clients em chamada
     Não há vantgem em escolher a app quando há chamada de espera
Manager: vai atribuir o tipo de consulta (e Vai alterar o tipo de cliente se ele for rejeitado na chamada?)
Gerador: vai gerir novos arrivals (exp(1/40))
arrival: cada paciente (que leva uma trajectory)
trajectory: a receita de cada arrival

```{r}
# atributes need to be numeric
tipo_de_consulta.PRESENCIAL <- 1
tipo_de_consulta.TELEFONICA <- 2
tipo_de_consulta.NAO_AGENDADA <- 3
tipos_de_consulta <- c(tipo_de_consulta.PRESENCIAL, tipo_de_consulta.TELEFONICA, tipo_de_consulta.NAO_AGENDADA)
tipos_de_consulta.probs <- c(0.1, 0.6, 0.3)

tipo_de_contacto.TELEFONE <- 1
tipo_de_contacto.APP <- 2
tipos_de_contacto <- c(tipo_de_contacto.TELEFONE, tipo_de_contacto.APP)
tipos_de_contacto.probs <- c(0.85, 0.15)

tempo_atendido <- function() {
  mean_time_triagem <- rnorm(1, mean = 4, sd = 1)
  mean_time_decision <- rnorm(1, mean = 1, sd = 0.25)
  time_to_timeout <- mean_time_triagem + mean_time_decision
  
  if (get_attribute(env, "tipo_de_consulta") != tipo_de_consulta.NAO_AGENDADA) {
    time_to_timeout <- time_to_timeout + rnorm(1, mean = 1, sd = 0.25)
  }
  
  return(time_to_timeout)
}

intime <- function() {
  now(env)%% 24*60 -> n
  return(8*60 < n & n < 18*60)
}
```


```{r}
pessoa <- trajectory("pessoa") %>%
  # set_attribute("times_phone_rejected", 0) %>% 
  # set_attribute("phone_rejected", 0) %>%
  set_attribute("tipo_de_consulta", \() sample(tipos_de_consulta, 1, prob = tipos_de_consulta.probs)) %>%
  set_attribute("tipo_de_contacto", \() sample(tipos_de_contacto, 1, prob = tipos_de_contacto.probs), tag = "contacto") %>%
  set_prioritization(\() if (get_attribute(env, "tipo_de_consulta") == tipo_de_consulta.TELEFONICA) c(1, -1, FALSE) else c(0 , -1, FALSE)) %>% # PRIORITY, DROP PRIORITY, RESTART
  # log_(\() paste("Vou pra fila agora, estou a usar", ifelse(get_attribute(env, "tipo_de_contacto") == tipo_de_contacto.TELEFONE, "o telefone", "a app"))) %>%
  renege_in(\() ifelse(get_attribute(env, "tipo_de_consulta") == tipo_de_consulta.TELEFONICA, 5, Inf), out = 
              trajectory() %>% set_attribute("phone_rejected", 1)
              # O botas não gostou
              # trajectory("pessoa_try_again") %>% 
              # set_attribute("times_phone_rejected", \() get_attribute(env, "times_phone_rejected") + 1) %>% 
              # # leave if out of schedule
              # leave(\() {ifelse(intime(), 0, 1)}) %>% 
              # # log_(\() "Nao fui atendido, vou voltar pra fila") %>% 
              # rollback(target="contacto", times = 1) # não funciona, mudar pra numero?
            ) %>%
  seize("administrador", 1) %>%
  renege_abort() %>%
  # log_(\() paste("Before timeout")) %>% 
  timeout(tempo_atendido) %>% 
  # log_(\() "After timeout") %>% 
  release("administrador", 1)
  # log_(\() "Leaving")

pessoa
```


```{r}
set.seed(1)
# 50 replicas
envs <- lapply(1:50, function(i) {
  env <<- simmer("hospital") 
  env %>% 
    add_generator("pessoa", pessoa, from_to(8*60, 18*60, \() rexp(1, 40/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_resource("administrador", schedule(c(8*60, 18*60), c(2, 0), period = 24*60)) %>%
    run(24*60*5)
})

envs %>% simmer.plot::get_mon_arrivals(ongoing = T) -> arrivals
envs %>% simmer.plot::get_mon_attributes() -> attributes
envs %>% simmer.plot::get_mon_resources() -> resources
```


```{r}
arrivals %>%
  filter(start_time != -1) %>% # n sei pq e q isto acontece
  arrange(start_time) %>% 
  select(-activity_time) %>% 
  mutate(
    day = ceiling(start_time/(24*60)),
    start_time_day = start_time %% (24*60) %>% seconds_to_period(),
    end_time_day = end_time %% (24*60) %>% seconds_to_period(),
  ) -> arrivals.df1
arrivals.df1 %>% filter(replication == 1) %>% mutate(replication = replication %>% as_factor(), start_time_day = start_time_day %>% round(3), end_time_day = end_time_day %>% round(3))
```

```{r}
# analise de eficiencia
# numero de chamadas perdidas
# add day to atributes from arrivals.df1
attributes %>% 
  left_join(arrivals.df1 %>% select(name, replication, day, end_time, end_time_day), by = c("name", "replication")) %>% 
  select(-time) -> attributrs.lj
attributrs.lj 
```


```{r}
# n diz nada
attributrs.lj %>% 
  filter(key == "phone_rejected") %>% 
  group_by(replication, day) %>%
  summarise(value = sum(value)) %>% 
  # boxplot per day
  ggplot(aes(x = factor(day), y = value)) +
  geom_boxplot()
```


```{r}
# evolucao ao longo do dia
attributrs.lj %>% 
  filter(key == "phone_rejected") %>% 
  mutate(day = day %>% as_factor(), replication = replication %>% as_factor) %>% 
  group_by(replication) %>% 
  reframe(time_rejected = end_time, sumcum_per_day = cumsum(value), day = day) %>% 
  ggplot(aes(x = time_rejected %>% as.integer(), y = sumcum_per_day)) +
  geom_line(aes(color = replication), alpha = 0.3) +
  geom_smooth() +
  facet_wrap(vars(day), scale = "free") +
  theme(legend.position = "none")
```


```{r}
# get queue size histogram
resources %>% 
  mutate(day = ceiling(time/(24*60))) %>% 
  group_by(replication) %>%
  reframe(day = day, time = time, queue_size = queue) %>% 
  ggplot(aes(x = time, y = queue_size)) +
  geom_step(aes(color = replication), alpha = 0.3) 

  

  

  
```

```{r}
resources %>% plot(metric = "utilization")
resources %>% plot(metric = "usage", steps = T)

```


```{r}
# mudanças
envs <- lapply(1:50, function(i) {
  env <<- simmer("hospital") 
  env %>% 
    add_generator("pessoa_de_manha", pessoa, from_to(8*60, 10*60, \() rexp(1, (120/2)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_generator("pessoa_de_tarde", pessoa, from_to(10*60, 16*60, \() rexp(1, (240/6)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_generator("pessoa_de_noite", pessoa, from_to(16*60, 18*60, \() rexp(1, (40/2)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_resource("administrador", schedule(
      c(8 , 9 , 9.5 , 12 , 15.5 ,18)*60, 
      c(  1 , 2,    4,   3,     1,  0), 
      period = 24*60
    )) %>%
    run(24*60*5)
})

envs %>% simmer.plot::get_mon_arrivals(ongoing = T) -> arrivals
envs %>% simmer.plot::get_mon_attributes() -> attributes
envs %>% simmer.plot::get_mon_resources() -> resources
```

```{r}
# b)
arrivals %>%
  filter(replication == 1) %>%
  arrange(start_time) %>% 
  select(-activity_time) %>% 
  mutate(
    day = ceiling(start_time/(24*60)),
    start_time = start_time %% (24*60) %>% seconds_to_period(),
    end_time = end_time %% (24*60) %>% seconds_to_period(),
  ) -> arrivals.df
arrivals.df %>% mutate(start_time = start_time %>% round(3), end_time = end_time %>% round(3))
```

```{r}
# a) set_prioritization(\() if (get_attribute(env, "tipo_de_consulta") == tipo_de_consulta.TELEFONICA) c(1, -1, FALSE) else c(0 , -1, FALSE))
pessoa__ <- join(
  pessoa[1:2], 
  trajectory("change_prio") %>% 
     set_prioritization(\() if (get_attribute(env, "tipo_de_consulta") == tipo_de_consulta.TELEFONICA) c(1, 1, FALSE) else c(0 , 0, FALSE)),
  pessoa[-(1:3)]
)
pessoa__
```


```{r}
envs <- lapply(1:50, function(i) {
  env <<- simmer("hospital") 
  env %>% 
    add_generator("pessoa_de_manha", pessoa__, from_to(8*60, 10*60, \() rexp(1, (120/2)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_generator("pessoa_de_tarde", pessoa__, from_to(10*60, 16*60, \() rexp(1, (240/6)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_generator("pessoa_de_noite", pessoa__, from_to(16*60, 18*60, \() rexp(1, (40/2)/60), every = 24*60, arrive = F), mon = 2) %>% 
    add_resource("administrador", schedule(
      c(8 , 9 , 9.5 , 12 , 15.5 ,18)*60, 
      c(  1 , 2,    4,   3,     1,  0), 
      period = 24*60
    )) %>%
    run(24*60*5)
})

envs %>% simmer.plot::get_mon_arrivals(ongoing = T) -> arrivals
envs %>% simmer.plot::get_mon_attributes() -> attributes
envs %>% simmer.plot::get_mon_resources() -> resources
```

```{r}
arrivals %>%
  arrange(start_time) %>% 
  select(-activity_time) %>% 
  mutate(
    day = ceiling(start_time/(24*60)),
    start_time = start_time %% (24*60) %>% seconds_to_period(),
    end_time = end_time %% (24*60) %>% seconds_to_period(),
  ) -> arrivals.df
arrivals.df %>% mutate(start_time = start_time %>% round(3), end_time = end_time %>% round(3))
```

